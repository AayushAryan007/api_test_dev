from django.shortcuts import render, redirect, get_object_or_404
from .models import Book
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .serializers import BookSerializer


class BookListCreateAPIView(APIView):
    def get(self, req):
        books = Book.objects.all()
        if req.headers.get('Accept') == 'application/json':
            serializer = BookSerializer(books, many=True)
            return Response(serializer.data)
        return render(req, "takebook.html", {"books": books})
    
    def post(self, req):
        if req.headers.get('Content-Type') == 'application/json':
            serializer = BookSerializer(data=req.data)
            if serializer.is_valid():
                serializer.save()
                return Response(serializer.data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        else:
            title = req.POST.get("title")
            author = req.POST.get("author")
            description = req.POST.get("description")
            picture = req.FILES.get("picture")
            Book.objects.create(title=title, author=author, description=description, picture=picture)
            return redirect("book-list-create")


class BookDetailAPIView(APIView):
    def get(self, req, id):
        book = get_object_or_404(Book, id=id)
        if req.headers.get('Accept') == 'application/json':
            serializer = BookSerializer(book)
            return Response(serializer.data)
        return render(req, "mybook.html", {"book": book})
    
    def put(self, req, id):
        book = get_object_or_404(Book, id=id)
        serializer = BookSerializer(book, data=req.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    def post(self, req, id):
        book = get_object_or_404(Book, id=id)
        book.title = req.POST.get("title")
        book.author = req.POST.get("author")
        book.description = req.POST.get("description")
        if req.FILES.get("picture"):
            book.picture = req.FILES.get("picture")
        book.save()
        return redirect("book-list-create")
    
    def delete(self, req, id):
        book = get_object_or_404(Book, id=id)
        book.delete()
        return redirect("book-list-create")


# Edit view
class BookEditAPIView(APIView):
    def get(self, req, id):
        book = get_object_or_404(Book, id=id)
        return render(req, "editbook.html", {"book": book})
    
    def post(self, req, id):
        book = get_object_or_404(Book, id=id)
        book.title = req.POST.get("title")
        book.author = req.POST.get("author")
        book.description = req.POST.get("description")
        if req.FILES.get("picture"):
            book.picture = req.FILES.get("picture")
        book.save()
        return redirect("book-list-create")




        ÷/////////////////


from django.shortcuts import render,redirect, get_object_or_404
from .models import Book

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .serializers import BookSerializer


class BookListCreateAPIView(APIView):
    # get all books 
    def get(self, req):
        books = Book.objects.all()
        serializer = BookSerializer(books, many=True)
        return Response(serializer.data)
    
    # create a book
    def post(self, req):
        serializer = BookSerializer(data = req.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)



class BookDetailAPIView(APIView):
    # get, put, delete a book by id
    def get(self, req, id):
        book = get_object_or_404(Book, id=id)
        serializer = BookSerializer(book)
        return Response(serializer.data)
    
    def put(self, req, id):
        book = get_object_or_404(Book, id=id)
        serializer = BookSerializer(book, data=req.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    def delete(self, req, id):
        book = get_object_or_404(Book, id=id)
        book.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
    


    ÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷

    GitHub Copilot

Summary of today’s work (concise)

- Project state
  - Django project with built-in User model, Book model, JWT auth; initial DB = sqlite (db.sqlite3); media stored in ./media.

- Dockerization
  - Added Dockerfile (switched to python:3.12-slim to match Django 6) and requirements.txt.
  - Created docker-compose.yml with two services: db (mysql:8.0) and web (Django/gunicorn).
  - Mounted ./media as a volume and passed DB credentials via environment vars.

- Settings & DB driver
  - settings.py updated to use MySQL via env vars (DB_HOST, DB_NAME, DB_USER, DB_PASS, DB_PORT).
  - Local mysqlclient install failed (pkg-config missing); two options used: install native deps via Homebrew or use PyMySQL with pymysql.install_as_MySQLdb() shim.

- Data migration from SQLite -> MySQL
  - Dumped sqlite data: python manage.py dumpdata --natural-foreign --natural-primary --exclude auth.permission --exclude contenttypes > data.json
  - Archived media: tar -czf media.tar.gz media/
  - Brought up MySQL container: docker compose up --detach db
  - Built web image and applied migrations to MySQL: docker compose run --rm web python manage.py migrate
  - Loaded data into MySQL: docker compose run --rm web python manage.py loaddata data.json
  - Restored media into mounted volume (untar into ./media)

- Troubleshooting during build/run
  - Dockerfile apt-get failed due to DNS/network inside build; resolved by restarting Docker Desktop, setting Docker daemon DNS (8.8.8.8 / 1.1.1.1) or using build with --network/host; rebuilt with docker compose build --no-cache --progress=plain web.
  - Fixed Django version vs Python mismatch by using python:3.12-slim base image.
  - Removed/ignored docker-compose `version:` warning.

- Verification
  - Confirmed MySQL tables: docker compose exec db mysql -u root -prootpass -e "USE proj1; SHOW TABLES;"
  - Verified app running: docker compose up --detach web and tested JWT auth + Book CRUD endpoints.

If a short command summary is needed (startup sequence), say so.




//////////////////////


# 1. Build images
docker compose build --no-cache web

# 2. Start only the database and wait until ready
docker compose up --detach db
docker compose logs -f db

# (optional) quick DB health check
docker compose exec db mysql -u root -prootpass -e "SELECT 1;"

# 3. Apply migrations on the MySQL database
docker compose run --rm web python manage.py migrate

# 4. Load dumped data (if you have data.json)
docker compose run --rm web python manage.py loaddata data.json

# 5. Restore media locally (if you have media archive)
tar -xzf media.tar.gz -C ./media

# 6. Start the web service
docker compose up --detach web

# 7. Follow logs and test
docker compose logs -f web

# 8. Stop & remove services (when needed)
docker compose down -v

//////////////////////////////////////////
Switch from Docker Desktop to Colima — Summary
What we did
1. Quit Docker Desktop

osascript -e 'tell application "Docker" to quit' || true
killall Docker || true

2. Install Colima + Docker CLI + docker-compose via Homebrew

brew update
brew install colima docker docker-compose

3. Start Colima VM with resource allocation

colima start --cpu 4 --memory 6 --disk 60

Colima creates a lightweight VM using Lima/QEMU to run Docker daemon.
Resources: 4 CPUs, 6GB RAM, 60GB disk (adjust as needed).

4. Verify Colima is running and Docker CLI connects to it

colima status
docker version
docker info

Docker CLI now points to Colima's socket (unix:///Users/<user>/.colima/default/docker.sock) instead of Docker Desktop's.

docker compose build --no-cache web
docker compose up --detach db
docker compose run --rm web python manage.py migrate
docker compose run --rm web python manage.py loaddata data.json
tar -xzf media.tar.gz -C ./media
docker compose up --detach web

/////////////////////////////

Task 3 ->
now in this project i want to be able to bulk upload the books data,
i will be using csv for tis bulk upload. the csv file data will be taken as inout and 
each row will create a single entry in the book database, 
lets say i  have 100 entries in the csv file and to upload them i will have a delay of 
0.5 second for each entry, means 60 entries must take atleast 30 second to upload to 
be created in db. nowwhile this upload happens, in the delay time a task id is created for the 
entry , we have to expose a status api , for every task id we should get a staus using that api 
if the upload was successful or it failed or stll going on., 
there must also be an api that returns
status of all entries task id in one place as they are uploaded


User (Postman)
    ↓
POST /bulk-upload/ [CSV file]
    ↓
LoginAPIView (JWT auth)
    ↓
BulkUploadBooksAPIView.post()
    ├─ Parse CSV rows
    ├─ Create BulkUploadTask records (status='pending')
    ├─ Enqueue Celery tasks to Redis
    └─ Return batch_id + task_ids (HTTP 202 Accepted)
    ↓
Redis Queue (stores pending tasks)
    ↓
Celery Worker (listens to Redis)
    ├─ Pull task from queue
    ├─ Execute process_book_upload(task_id)
    │  ├─ Sleep 0.5s (simulated delay)
    │  ├─ Create Book entry
    │  ├─ Update BulkUploadTask (status='success')
    │  └─ Store result in Redis
    └─ Next task...
    ↓
GET /task-status/?task_id= [User polls]
    └─ TaskStatusAPIView queries BulkUploadTask
       └─ Return status from DB (success/pending/failed)
    ↓
GET /batch-status/?batch_id= [User polls]
    └─ BatchStatusAPIView aggregates all tasks
       └─ Return summary (total/pending/success/failed)




////////////////////////////////////
task 4->
we have to switch from csrf to authentication token,
the token will contain detail like status, messgae, token , active or not,
we need a middleware that will help se generate that auth token on login signup
the token generation will be using uuid4 and will be of lenght 64 character
need data like user identity (hash , signature), token validity, expiration, 
optional(permission , scope), 
this middleware is important as now this will sit between every request response cycle for authorisation 
using the auth token(based on its presence, expiration, active state)
each request will validate the auth toke like
request.data.{profile} -> user authenticated?
so now wehn i use postman for login api using my username and password
i will be getting a auth token using middleare which will be in my middleware, and. when i send any request or 
response composeit first goes through the middleware to validate the auth token

